var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = CounterfactualTraining","category":"page"},{"location":"#CounterfactualTraining","page":"Home","title":"CounterfactualTraining","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for CounterfactualTraining.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [CounterfactualTraining]","category":"page"},{"location":"#CounterfactualTraining.AbstractObjective","page":"Home","title":"CounterfactualTraining.AbstractObjective","text":"Base type of training objectives.\n\n\n\n\n\n","category":"type"},{"location":"#CounterfactualTraining.AdversarialObjective","page":"Home","title":"CounterfactualTraining.AdversarialObjective","text":"(obj::AdversarialObjective)(\n    yhat,\n    y,\n    energy_differential::Vector{<:AbstractFloat}=[0.0f0],\n    regularization::Vector{<:AbstractFloat}=[0.0f0],\n    adversarial_loss::Union{AbstractFloat,Vector{<:AbstractFloat}}=0.0f0;\n    agg=mean,\n    kwrgs...,\n)\n\nIf the adversarial_loss has been computed already, obj::AdversarialObjective can be called directly on predictions yhat and labels y. The different loss components are then added together with a weighting vector lambda.\n\n\n\n\n\n","category":"type"},{"location":"#CounterfactualTraining.AdversarialObjective-2","page":"Home","title":"CounterfactualTraining.AdversarialObjective","text":"AdversarialObjective <: AbstractObjective\n\nThe AdversarialObjective is a concrete implementation of the AbstractObjective abstract type that optimizes for:\n\nStandard classification objective (the discriminative task).\nAdversarial classification objective on the counterfactuals (the explainability task).\n\n\n\n\n\n","category":"type"},{"location":"#CounterfactualTraining.AdversarialObjective-Tuple{}","page":"Home","title":"CounterfactualTraining.AdversarialObjective","text":"AdversarialObjective(;\n    class_loss::Function=Flux.Losses.logitcrossentropy,\n    lambda::Vector{<:AbstractFloat}=[1.0, 0.1]\n)\n\nOuter constructor for the AdversarialObjective type.\n\n\n\n\n\n","category":"method"},{"location":"#CounterfactualTraining.EnergyDifferentialObjective","page":"Home","title":"CounterfactualTraining.EnergyDifferentialObjective","text":"(obj::EnergyDifferentialObjective)(\n    yhat,\n    y,\n    energy_differential::Vector{<:AbstractFloat}=[0.0f0],\n    regularization::Vector{<:AbstractFloat}=[0.0f0],\n    adversarial_loss::Union{AbstractFloat,Vector{<:AbstractFloat}}=0.0f0;\n    agg=mean,\n    kwrgs...,\n)\n\nIf the energy_differential and regularization have been computed already, obj::EnergyDifferentialObjective can be called directly on predictions yhat and labels y. The different loss components are then added together with a weighting vector lambda.\n\n\n\n\n\n","category":"type"},{"location":"#CounterfactualTraining.EnergyDifferentialObjective-2","page":"Home","title":"CounterfactualTraining.EnergyDifferentialObjective","text":"EnergyDifferentialObjective <: AbstractObjective\n\nThe EnergyDifferentialObjective is a concrete implementation of the AbstractObjective abstract type that optimizes for:\n\nStandard classification objective (the discriminative task)\nEnergy differential between counterfactuals and observed data (the explainability task).\n\n\n\n\n\n","category":"type"},{"location":"#CounterfactualTraining.EnergyDifferentialObjective-Tuple{}","page":"Home","title":"CounterfactualTraining.EnergyDifferentialObjective","text":"EnergyDifferentialObjective(;\n    class_loss::Function=Flux.Losses.logitcrossentropy, \n    lambda::Vector{<:AbstractFloat}=[1.0, 0.5, 0.0001]\n)\n\nOuter constructor for the EnergyDifferentialObjective type.\n\n\n\n\n\n","category":"method"},{"location":"#CounterfactualTraining.FullObjective","page":"Home","title":"CounterfactualTraining.FullObjective","text":"(obj::FullObjective)(\n    yhat,\n    y,\n    energy_differential::Vector{<:AbstractFloat}=[0.0f0],\n    regularization::Vector{<:AbstractFloat}=[0.0f0],\n    adversarial_loss::Union{AbstractFloat,Vector{<:AbstractFloat}}=[0.0f0];\n    agg=mean,\n    kwrgs...,\n)\n\nIf the adversarial_loss has been computed already, obj::FullObjective can be called directly on predictions yhat and labels y. The different loss components are then added together with a weighting vector lambda.\n\n\n\n\n\n","category":"type"},{"location":"#CounterfactualTraining.FullObjective-2","page":"Home","title":"CounterfactualTraining.FullObjective","text":"FullObjective <: AbstractObjective\n\nThe FullObjective is a concrete implementation of the AbstractObjective abstract type that optimizes for all three tasks:\n\nStandard classification objective (the discriminative task)\nEnergy differential between counterfactuals and observed data (the explainability task).\nAdversarial classification objective on the counterfactuals (the explainability task).\n\n\n\n\n\n","category":"type"},{"location":"#CounterfactualTraining.FullObjective-Tuple{}","page":"Home","title":"CounterfactualTraining.FullObjective","text":"FullObjective(;\n    class_loss::Function=Flux.Losses.logitcrossentropy,\n    energy_differential::PenaltyOrFun=EnergyDifferential(),\n    lambda::Vector{<:AbstractFloat}=[1.0, 0.5, 0.0001, 0.1]\n)\n\nOuter constructor for the FullObjective type.\n\n\n\n\n\n","category":"method"},{"location":"#CounterfactualTraining.VanillaObjective","page":"Home","title":"CounterfactualTraining.VanillaObjective","text":"(obj::VanillaObjective)(\n    yhat,\n    y,\n    energy_differential::Vector{<:AbstractFloat}=[0.0f0],\n    regularization::Vector{<:AbstractFloat}=[0.0f0],\n    adversarial_loss::Union{AbstractFloat,Vector{<:AbstractFloat}}=0.0f0;\n    agg=mean,\n    kwrgs...,\n)\n\nobj::VanillaObjective can be called directly on predictions yhat and labels y.\n\n\n\n\n\n","category":"type"},{"location":"#CounterfactualTraining.VanillaObjective-2","page":"Home","title":"CounterfactualTraining.VanillaObjective","text":"VanillaObjective <: AbstractObjective\n\nThe VanillaObjective is a concrete implementation of the AbstractObjective abstract type that optimizes for:\n\nStandard classification objective (the discriminative task).\n\n\n\n\n\n","category":"type"},{"location":"#CounterfactualTraining.VanillaObjective-Tuple{}","page":"Home","title":"CounterfactualTraining.VanillaObjective","text":"VanillaObjective(;\n    class_loss::Function=Flux.Losses.logitcrossentropy,\n    lambda::Vector{<:AbstractFloat}=[1.0],\n)\n\nOuter constructor for the VanillaObjective type.\n\n\n\n\n\n","category":"method"},{"location":"#CounterfactualTraining.adv_loss-NTuple{4, Any}","page":"Home","title":"CounterfactualTraining.adv_loss","text":"adv_loss(\n    model, counterfactual, perturbations, targets; epsilon=2.0, p::Real=Inf, validities=nothing\n)\n\nAdversarial loss function.\n\n\n\n\n\n","category":"method"},{"location":"#CounterfactualTraining.generate!-Tuple{Any, Any, CounterfactualExplanations.AbstractGenerator}","page":"Home","title":"CounterfactualTraining.generate!","text":"generate!(\n    model,\n    data,\n    generator::AbstractGenerator;\n    nsamples::Union{Int,Nothing}=nothing,\n    convergence=Convergence.MaxIterConvergence(),\n    parallelizer=nothing,\n    input_encoder=nothing,\n    verbose=1,\n    domain=nothing,\n)\n\nThis function generates counterfactual explanations for the whole dataset data or a subset thereof (nsamples). It is supposed to be used outside of the mini-batch training loop.\n\n\n\n\n\n","category":"method"},{"location":"#CounterfactualTraining.get_global_ae_criterium-Tuple{}","page":"Home","title":"CounterfactualTraining.get_global_ae_criterium","text":"get_global_ae_criterium()\n\nGet the global AE criterium.\n\n\n\n\n\n","category":"method"},{"location":"#CounterfactualTraining.get_last_valid_ae-Tuple{CounterfactualExplanations.CounterfactualExplanation}","page":"Home","title":"CounterfactualTraining.get_last_valid_ae","text":"get_last_valid_ae(ce::CounterfactualExplanation)\n\nA callback function used to store the last counterfactual that is also a valid adversarial example based on the global AE criterium (see get_global_ae_criterium).\n\n\n\n\n\n","category":"method"},{"location":"#CounterfactualTraining.implausibility-NTuple{4, Any}","page":"Home","title":"CounterfactualTraining.implausibility","text":"implausibility(model, counterfactual, samples, targets)\n\nCompute the implausibility (contrastive divergence) of the counterfactuals (counterfactual) with respect to samples in the target class. This is computed as the difference between negative logits indexed at the target class for the samples and the counterfactual.\n\n\n\n\n\n","category":"method"},{"location":"#CounterfactualTraining.infer_domain_constraints-Tuple{AbstractArray}","page":"Home","title":"CounterfactualTraining.infer_domain_constraints","text":"infer_domain_constraints(X::AbstractArray; nstd=3)\n\nAutomatically infers reasonable domain constraints for the counterfactuals. \n\n\n\n\n\n","category":"method"},{"location":"#CounterfactualTraining.isvalid-Tuple{CounterfactualExplanations.AbstractCounterfactualExplanation, Any, Any}","page":"Home","title":"CounterfactualTraining.isvalid","text":"isvalid(ce, model, data)\n\nChecks if the label has been flipped.\n\n\n\n\n\n","category":"method"},{"location":"#CounterfactualTraining.protect_immutable!-Tuple{AbstractArray, AbstractArray, Union{Nothing, AbstractArray}}","page":"Home","title":"CounterfactualTraining.protect_immutable!","text":"protect_immutable!(\n    samples::AbstractArray,\n    counterfactuals::AbstractArray,\n    mutability::Union{Nothing,AbstractArray},\n)\n\nProtects immutable features from the contrastive divergence penalty.\n\n\n\n\n\n","category":"method"},{"location":"#CounterfactualTraining.reg_loss-NTuple{4, Any}","page":"Home","title":"CounterfactualTraining.reg_loss","text":"reg_loss(model, counterfactual, samples, targets)\n\nCompute the regularization loss for the contrastice divergence.\n\n\n\n\n\n","category":"method"},{"location":"#CounterfactualTraining.setup_counterfactual_search-Tuple{Any, Any, Any, Any, Any, Int64, Union{Nothing, Int64}}","page":"Home","title":"CounterfactualTraining.setup_counterfactual_search","text":"setup_counterfactual_search(\n    data,\n    model,\n    domain,\n    input_encoder,\n    mutability,\n    nneighbours::Int64,\n    nsamples::Union{Nothing,Int64},\n)\n\nSets up the counterfactual search.\n\n\n\n\n\n","category":"method"},{"location":"#CounterfactualTraining.unwrap-Tuple{Any}","page":"Home","title":"CounterfactualTraining.unwrap","text":"unwrap(train_set; labels=nothing)\n\nUnwraps the data from a Flux.DataLoader or zip iterator. The output variables is assumed to be categorical. If no labels are provided, then 1 to n is used where n is the number of classes.\n\n\n\n\n\n","category":"method"}]
}
